import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.*;

public class Huffman {
  
  public static String huffmanEncoder(String inputFileName, String encodingFileName, String outputFileName) {
    
    try {
      ArrayList<HuffmanNode> sortedList = Huffman.findFrequency(inputFileName);
      /*for (int i = 0; i < sortedList.size(); i++)
       System.out.println((sortedList.get(i)).getInChar() + " " + sortedList.get(i).getFrequency());*/
      HuffmanNode treeNode = Huffman.generateTree(sortedList);
      if (treeNode.isLeafNode())
        System.out.println(treeNode.getInChar() + ":" + treeNode.getFrequency() + ":0");
      else
        Huffman.listEncoding(treeNode, "");
      Huffman.encodeFile(inputFileName, encodingFileName, outputFileName);
      
      return "Encoding Successful";
    }
    catch (IOException e) { 
      return e.getMessage();
    }
    
    
  }
  
  /*
   * Finds the frequency of each character in the entered file
   * Generates initial list of Huffman nodes
   * Sorts the list in ascending order of frequency
   * @param fileName the name of the file to be searched
   * @return nodeList the list of sorted Huffman Nodes
   */
  public static ArrayList<HuffmanNode> findFrequency(String fileName) throws IOException {
    
    InputStream in = new FileInputStream(fileName);
    Reader reader = new InputStreamReader(in);
    int charASCIIvalue; //ASCII value of a character
    /* stores frequencies of characters appearing in the file, stored at their corresponding ASCII index in the array
     * size of extended english ASCII table */
    int[] frequencies = new int[256];
    ArrayList<Integer> extraChars = new ArrayList<>(); //stores any extra characters not contained in the extended ASCII English table
    ArrayList<Integer> extraFreqs = new ArrayList<>(); //stores the corresponding frequencies for any extra characters
    /* Loops through the file one character at a time */
    while ((charASCIIvalue = reader.read()) != -1) {
      try {
        frequencies[charASCIIvalue] = frequencies[charASCIIvalue] + 1; //Increases frequency by one at corresponding ASCII index
      }
      /* If the character is not a part of the extended English ASCII table */
      catch (IndexOutOfBoundsException e) {
        boolean loopEntered = false;
        for (int i = 0; i < extraChars.size(); i++) { //Loops across extraChars array
          loopEntered = true;
          if (charASCIIvalue == extraChars.get(i)) { //checking if the character has been encountered before and already exists in the array
            extraFreqs.set(i, extraFreqs.get(i) + 1); //increase frequency by one
          }
        }
        if (!loopEntered) { //if the character has not been encountered, add it to the array
          extraChars.add(charASCIIvalue);
          extraFreqs.add(1);
        }
      }
    }
    
    ArrayList<HuffmanNode> nodeList = new ArrayList<HuffmanNode>(); //list to store the ordered nodes, in ascending order
    /* Loops across the array representing the frequencies of characters that appeared in the file */
    for (int i = 0; i < frequencies.length; i++) {
      if (frequencies[i] != 0) { //if the corresponding character appeared in the file, add it to the new list
        HuffmanNode currentNode = new HuffmanNode((char)i, frequencies[i]);
        nodeList.add(currentNode);
      }
    }
    if (extraChars.size() != 0) { //if there are characters that appeared in the file that are not in the extended English ASCII table
      for (int i = 0; i < extraChars.size(); i++) { //for each item in the list create and add a node to the new list
        HuffmanNode currentNode = new HuffmanNode((char)((int)extraChars.get(i)), extraFreqs.get(i));
        nodeList.add(currentNode);
      }
    }
      
    Collections.sort(nodeList); //Sort the list in ascending order of frequencies
      
    return nodeList;
    
  }
  
  /*
   * Merges two HuffmanNodes and returns the combined node
   * @param node1 the first node to be merged
   * @param node2 the second node to be merged
   * @return HuffmanNode the combined node
   */
  public static HuffmanNode mergeNodes(HuffmanNode node1, HuffmanNode node2) {
    
    if (node1.getFrequency() < node2.getFrequency()) //if the first node has a greater frequency than the second node
      return new HuffmanNode(null, node1.getFrequency() + node2.getFrequency(), node1, node2);
    else //if the second node's frequency is greater than or equal to the first node's frequency
      return new HuffmanNode(null, node1.getFrequency() + node2.getFrequency(), node2, node1);
    
  }
  
  /*
   * Generates the Huffman encoding tree for the specified sorted list of Huffman nodes using recursion
   * @param nodeList list of sorted Huffman nodes
   * @return finalNode the root of the final Huffman tree
   */
  public static HuffmanNode generateTree(ArrayList<HuffmanNode> nodeList) {
    
    if (nodeList.size() == 0) //if the list is empty
      return null;
    
    else if (nodeList.size() == 1) //base case when final tree is generated
      return nodeList.get(0);
    
    else {
      /* combine the lowest two frequency nodes to make one combined node with the two nodes as its children */
      HuffmanNode combinedNode = mergeNodes(nodeList.get(0), nodeList.get(1));
      /* remove the nodes we previously combined */
      nodeList.remove(0);
      nodeList.remove(0);
      boolean nodeAdded = false; //to keep track of whether the node was inserted
      /* loops over the whole node list */
      for (int i = 0; i < nodeList.size(); i++) {
        /* searches for where to place the combined node to keep the list in ascending order
         * only enters when the combined node has not been added to the list already */
        if (combinedNode.getFrequency() < nodeList.get(i).getFrequency() && !nodeAdded) {
          nodeList.add(i, combinedNode);
          nodeAdded = true;
        }
      }
      if (!nodeAdded) //if the node was not added, ie. if the node is the largest of the list, add it to the end of the list
        nodeList.add(combinedNode);
      
      HuffmanNode finalNode = generateTree(nodeList); //keep combining the nodes in the list until there is only one node in the list, the root node
      
      return finalNode;
    }
    
  }
  
  /*
  public static ArrayList<HuffmanNode> helperMethod(ArrayList<HuffmanNode> nodeList) {
    
    HuffmanNode combinedNode = mergeNodes(nodeList.get(0), nodeList.get(1));
      nodeList.remove(0);
      nodeList.remove(0);
      boolean nodeAdded = false;
      for (int i = 0; i < nodeList.size(); i++) {
        //System.out.println("helper   " + nodeList.size());
        if (combinedNode.getFrequency() < nodeList.get(i).getFrequency() && !nodeAdded) {
          nodeList.add(i, combinedNode);
          nodeAdded = true;
        }
      }
      if (!nodeAdded)
        nodeList.add(combinedNode);
      
      return nodeList;
    
  }
  */
  
  /*
   * Lists the Huffman encoding specified by the tree
   * @param rootNode the root node representing the Huffman tree
   * @param path the path in binary from the root node to a certain node
   */
  public static void listEncoding(HuffmanNode rootNode, String path) {

    if (rootNode.isLeafNode()) { //if the node being checked is a leaf node
      rootNode.setPath(path);
      System.out.println(rootNode.getInChar() + ":" + rootNode.getFrequency() + ":" + rootNode.getPath()); //print out info about node
    }
    else { //if the node is an interior node, perform recursion on it's children until a leaf node is found
      listEncoding(rootNode.getLeft(), path + "0"); //when going to a nodes left child, 0 is added to the path
      listEncoding(rootNode.getRight(), path + "1"); //when going to a nodes right child, 1 is added to the path
    }
    
  }
  
  /*
   * Encodes the specified file using the huffman coding generated
   */
  public static void encodeFile(String inputFileName, String encodingFileName, String outputFileName) throws IOException {
    
    InputStream in = new FileInputStream(inputFileName);
    Reader reader = new InputStreamReader(in);
    int charASCIIvalue; //ASCII value of a character
    while ((charASCIIvalue = reader.read()) != -1) {
      char currentChar = (char)charASCIIvalue;
      
    }
  }
  
}

/* How do we output the file. Is the output filename an empty file? */
/* What do we output for the path if there is only one item */
